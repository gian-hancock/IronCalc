use core::fmt;
use std::{array::IntoIter, panic};

use crate::{
    calc_result::CalcResult,
    expressions::{parser::Node, token::Error, types::CellReferenceIndex},
    model::Model,
};

pub(crate) mod binary_search;
mod date_and_time;
mod engineering;
mod financial;
mod financial_util;
mod information;
mod logical;
mod lookup_and_reference;
mod mathematical;
mod statistical;
mod subtotal;
mod text;
mod text_util;
pub(crate) mod util;
mod xlookup;

/// List of all implemented functions
#[derive(PartialEq, Clone, Debug)]
pub enum Function {
    // Logical
    And,
    False,
    If,
    Iferror,
    Ifna,
    Ifs,
    Not,
    Or,
    Switch,
    True,
    Xor,

    // Mathematical and trigonometry
    Abs,
    Acos,
    Acosh,
    Asin,
    Asinh,
    Atan,
    Atan2,
    Atanh,
    Choose,
    Column,
    Columns,
    Cos,
    Cosh,
    Max,
    Min,
    Pi,
    Power,
    Product,
    Rand,
    Randbetween,
    Round,
    Rounddown,
    Roundup,
    Sin,
    Sinh,
    Sqrt,
    Sqrtpi,
    Sum,
    Sumif,
    Sumifs,
    Tan,
    Tanh,

    // Information
    ErrorType,
    Formulatext,
    Isblank,
    Iserr,
    Iserror,
    Iseven,
    Isformula,
    Islogical,
    Isna,
    Isnontext,
    Isnumber,
    Isodd,
    Isref,
    Istext,
    Na,
    Sheet,
    Type,

    // Lookup and reference
    Hlookup,
    Index,
    Indirect,
    Lookup,
    Match,
    Offset,
    Row,
    Rows,
    Vlookup,
    Xlookup,

    // Text
    Concat,
    Concatenate,
    Exact,
    Find,
    Left,
    Len,
    Lower,
    Mid,
    Rept,
    Right,
    Search,
    Substitute,
    T,
    Text,
    Textafter,
    Textbefore,
    Textjoin,
    Trim,
    Unicode,
    Upper,
    Value,
    Valuetotext,

    // Statistical
    Average,
    Averagea,
    Averageif,
    Averageifs,
    Count,
    Counta,
    Countblank,
    Countif,
    Countifs,
    Maxifs,
    Minifs,

    // Date and time
    Date,
    Day,
    Edate,
    Eomonth,
    Month,
    Now,
    Today,
    Year,

    // Financial
    Cumipmt,
    Cumprinc,
    Db,
    Ddb,
    Dollarde,
    Dollarfr,
    Effect,
    Fv,
    Ipmt,
    Irr,
    Ispmt,
    Mirr,
    Nominal,
    Nper,
    Npv,
    Pduration,
    Pmt,
    Ppmt,
    Pv,
    Rate,
    Rri,
    Sln,
    Syd,
    Tbilleq,
    Tbillprice,
    Tbillyield,
    Xirr,
    Xnpv,

    // Engineering: Bessel and transcendental functions
    Besseli,
    Besselj,
    Besselk,
    Bessely,
    Erf,
    Erfc,
    ErfcPrecise,
    ErfPrecise,

    // Engineering: Number systems
    Bin2dec,
    Bin2hex,
    Bin2oct,
    Dec2Bin,
    Dec2hex,
    Dec2oct,
    Hex2bin,
    Hex2dec,
    Hex2oct,
    Oct2bin,
    Oct2dec,
    Oct2hex,

    // Engineering: Bit functions
    Bitand,
    Bitlshift,
    Bitor,
    Bitrshift,
    Bitxor,

    // Engineering: Complex functions
    Complex,
    Imabs,
    Imaginary,
    Imargument,
    Imconjugate,
    Imcos,
    Imcosh,
    Imcot,
    Imcsc,
    Imcsch,
    Imdiv,
    Imexp,
    Imln,
    Imlog10,
    Imlog2,
    Impower,
    Improduct,
    Imreal,
    Imsec,
    Imsech,
    Imsin,
    Imsinh,
    Imsqrt,
    Imsub,
    Imsum,
    Imtan,

    // Engineering: Misc function
    Convert,
    Delta,
    Gestep,
    Subtotal,
}

impl Function {
    pub fn into_iter() -> IntoIter<Function, 194> {
        [
            Function::And,
            Function::False,
            Function::If,
            Function::Iferror,
            Function::Ifna,
            Function::Ifs,
            Function::Not,
            Function::Or,
            Function::Switch,
            Function::True,
            Function::Xor,
            Function::Sin,
            Function::Cos,
            Function::Tan,
            Function::Asin,
            Function::Acos,
            Function::Atan,
            Function::Sinh,
            Function::Cosh,
            Function::Tanh,
            Function::Asinh,
            Function::Acosh,
            Function::Atanh,
            Function::Abs,
            Function::Pi,
            Function::Sqrt,
            Function::Sqrtpi,
            Function::Atan2,
            Function::Power,
            Function::Max,
            Function::Min,
            Function::Product,
            Function::Rand,
            Function::Randbetween,
            Function::Round,
            Function::Rounddown,
            Function::Roundup,
            Function::Sum,
            Function::Sumif,
            Function::Sumifs,
            Function::Choose,
            Function::Column,
            Function::Columns,
            Function::Index,
            Function::Indirect,
            Function::Hlookup,
            Function::Lookup,
            Function::Match,
            Function::Offset,
            Function::Row,
            Function::Rows,
            Function::Vlookup,
            Function::Xlookup,
            Function::Concatenate,
            Function::Exact,
            Function::Value,
            Function::T,
            Function::Valuetotext,
            Function::Concat,
            Function::Find,
            Function::Left,
            Function::Len,
            Function::Lower,
            Function::Mid,
            Function::Right,
            Function::Search,
            Function::Text,
            Function::Trim,
            Function::Unicode,
            Function::Upper,
            Function::Isnumber,
            Function::Isnontext,
            Function::Istext,
            Function::Islogical,
            Function::Isblank,
            Function::Iserr,
            Function::Iserror,
            Function::Isna,
            Function::Na,
            Function::Isref,
            Function::Isodd,
            Function::Iseven,
            Function::ErrorType,
            Function::Formulatext,
            Function::Isformula,
            Function::Type,
            Function::Sheet,
            Function::Average,
            Function::Averagea,
            Function::Averageif,
            Function::Averageifs,
            Function::Count,
            Function::Counta,
            Function::Countblank,
            Function::Countif,
            Function::Countifs,
            Function::Maxifs,
            Function::Minifs,
            Function::Year,
            Function::Day,
            Function::Month,
            Function::Eomonth,
            Function::Date,
            Function::Edate,
            Function::Today,
            Function::Now,
            Function::Pmt,
            Function::Pv,
            Function::Rate,
            Function::Nper,
            Function::Fv,
            Function::Ppmt,
            Function::Ipmt,
            Function::Npv,
            Function::Mirr,
            Function::Irr,
            Function::Xirr,
            Function::Xnpv,
            Function::Rept,
            Function::Textafter,
            Function::Textbefore,
            Function::Textjoin,
            Function::Substitute,
            Function::Ispmt,
            Function::Rri,
            Function::Sln,
            Function::Syd,
            Function::Nominal,
            Function::Effect,
            Function::Pduration,
            Function::Tbillyield,
            Function::Tbillprice,
            Function::Tbilleq,
            Function::Dollarde,
            Function::Dollarfr,
            Function::Ddb,
            Function::Db,
            Function::Cumprinc,
            Function::Cumipmt,
            Function::Besseli,
            Function::Besselj,
            Function::Besselk,
            Function::Bessely,
            Function::Erf,
            Function::ErfPrecise,
            Function::Erfc,
            Function::ErfcPrecise,
            Function::Bin2dec,
            Function::Bin2hex,
            Function::Bin2oct,
            Function::Dec2Bin,
            Function::Dec2hex,
            Function::Dec2oct,
            Function::Hex2bin,
            Function::Hex2dec,
            Function::Hex2oct,
            Function::Oct2bin,
            Function::Oct2dec,
            Function::Oct2hex,
            Function::Bitand,
            Function::Bitlshift,
            Function::Bitor,
            Function::Bitrshift,
            Function::Bitxor,
            Function::Complex,
            Function::Imabs,
            Function::Imaginary,
            Function::Imargument,
            Function::Imconjugate,
            Function::Imcos,
            Function::Imcosh,
            Function::Imcot,
            Function::Imcsc,
            Function::Imcsch,
            Function::Imdiv,
            Function::Imexp,
            Function::Imln,
            Function::Imlog10,
            Function::Imlog2,
            Function::Impower,
            Function::Improduct,
            Function::Imreal,
            Function::Imsec,
            Function::Imsech,
            Function::Imsin,
            Function::Imsinh,
            Function::Imsqrt,
            Function::Imsub,
            Function::Imsum,
            Function::Imtan,
            Function::Convert,
            Function::Delta,
            Function::Gestep,
            Function::Subtotal,
        ]
        .into_iter()
    }
}

impl Function {
    /// Some functions in Excel like CONCAT are stringified as `_xlfn.CONCAT`.
    pub fn to_xlsx_string(&self) -> String {
        match self {
            Function::Concat => "_xlfn.CONCAT".to_string(),
            Function::Ifna => "_xlfn.IFNA".to_string(),
            Function::Ifs => "_xlfn.IFS".to_string(),
            Function::Maxifs => "_xlfn.MAXIFS".to_string(),
            Function::Minifs => "_xlfn.MINIFS".to_string(),
            Function::Switch => "_xlfn.SWITCH".to_string(),
            Function::Xlookup => "_xlfn.XLOOKUP".to_string(),
            Function::Xor => "_xlfn.XOR".to_string(),
            Function::Textbefore => "_xlfn.TEXTBEFORE".to_string(),
            Function::Textafter => "_xlfn.TEXTAFTER".to_string(),
            Function::Textjoin => "_xlfn.TEXTJOIN".to_string(),
            Function::Unicode => "_xlfn.UNICODE".to_string(),
            Function::Rri => "_xlfn.RRI".to_string(),
            Function::Pduration => "_xlfn.PDURATION".to_string(),
            Function::Bitand => "_xlfn.BITAND".to_string(),
            Function::Bitor => "_xlfn.BITOR".to_string(),
            Function::Bitxor => "_xlfn.BITXOR".to_string(),
            Function::Bitlshift => "_xlfn.BITLSHIFT".to_string(),
            Function::Bitrshift => "_xlfn.BITRSHIFT".to_string(),
            Function::Imtan => "_xlfn.IMTAN".to_string(),
            Function::Imsinh => "_xlfn.IMSINH".to_string(),
            Function::Imcosh => "_xlfn.IMCOSH".to_string(),
            Function::Imcot => "_xlfn.IMCOT".to_string(),
            Function::Imcsc => "_xlfn.IMCSC".to_string(),
            Function::Imcsch => "_xlfn.IMCSCH".to_string(),
            Function::Imsec => "_xlfn.IMSEC".to_string(),
            Function::ErfcPrecise => "_xlfn.ERFC.PRECISE".to_string(),
            Function::ErfPrecise => "_xlfn.ERF.PRECISE".to_string(),
            Function::Valuetotext => "_xlfn.VALUETOTEXT".to_string(),
            Function::Isformula => "_xlfn.ISFORMULA".to_string(),
            Function::Sheet => "_xlfn.SHEET".to_string(),
            Function::Formulatext => "_xlfn.FORMULATEXT".to_string(),
            _ => self.to_string(),
        }
    }

    pub(crate) fn returns_reference(&self) -> bool {
        matches!(self, Function::Indirect | Function::Offset)
    }
    /// Gets the function from the name.
    /// Note that in Excel some (modern) functions are prefixed by `_xlfn.`
    pub fn get_function(name: &str) -> Option<Function> {
        match name.to_ascii_uppercase().as_str() {
            "AND" => Some(Function::And),
            "FALSE" => Some(Function::False),
            "IF" => Some(Function::If),
            "IFERROR" => Some(Function::Iferror),
            "IFNA" | "_XLFN.IFNA" => Some(Function::Ifna),
            "IFS" | "_XLFN.IFS" => Some(Function::Ifs),
            "NOT" => Some(Function::Not),
            "OR" => Some(Function::Or),
            "SWITCH" | "_XLFN.SWITCH" => Some(Function::Switch),
            "TRUE" => Some(Function::True),
            "XOR" | "_XLFN.XOR" => Some(Function::Xor),

            "SIN" => Some(Function::Sin),
            "COS" => Some(Function::Cos),
            "TAN" => Some(Function::Tan),

            "ASIN" => Some(Function::Asin),
            "ACOS" => Some(Function::Acos),
            "ATAN" => Some(Function::Atan),

            "SINH" => Some(Function::Sinh),
            "COSH" => Some(Function::Cosh),
            "TANH" => Some(Function::Tanh),

            "ASINH" => Some(Function::Asinh),
            "ACOSH" => Some(Function::Acosh),
            "ATANH" => Some(Function::Atanh),

            "PI" => Some(Function::Pi),
            "ABS" => Some(Function::Abs),
            "SQRT" => Some(Function::Sqrt),
            "SQRTPI" => Some(Function::Sqrtpi),
            "POWER" => Some(Function::Power),
            "ATAN2" => Some(Function::Atan2),

            "MAX" => Some(Function::Max),
            "MIN" => Some(Function::Min),
            "PRODUCT" => Some(Function::Product),
            "RAND" => Some(Function::Rand),
            "RANDBETWEEN" => Some(Function::Randbetween),
            "ROUND" => Some(Function::Round),
            "ROUNDDOWN" => Some(Function::Rounddown),
            "ROUNDUP" => Some(Function::Roundup),
            "SUM" => Some(Function::Sum),
            "SUMIF" => Some(Function::Sumif),
            "SUMIFS" => Some(Function::Sumifs),

            // Lookup and Reference
            "CHOOSE" => Some(Function::Choose),
            "COLUMN" => Some(Function::Column),
            "COLUMNS" => Some(Function::Columns),
            "INDEX" => Some(Function::Index),
            "INDIRECT" => Some(Function::Indirect),
            "HLOOKUP" => Some(Function::Hlookup),
            "LOOKUP" => Some(Function::Lookup),
            "MATCH" => Some(Function::Match),
            "OFFSET" => Some(Function::Offset),
            "ROW" => Some(Function::Row),
            "ROWS" => Some(Function::Rows),
            "VLOOKUP" => Some(Function::Vlookup),
            "XLOOKUP" | "_XLFN.XLOOKUP" => Some(Function::Xlookup),

            "CONCATENATE" => Some(Function::Concatenate),
            "EXACT" => Some(Function::Exact),
            "VALUE" => Some(Function::Value),
            "T" => Some(Function::T),
            "VALUETOTEXT" | "_XLFN.VALUETOTEXT" => Some(Function::Valuetotext),
            "CONCAT" | "_XLFN.CONCAT" => Some(Function::Concat),
            "FIND" => Some(Function::Find),
            "LEFT" => Some(Function::Left),
            "LEN" => Some(Function::Len),
            "LOWER" => Some(Function::Lower),
            "MID" => Some(Function::Mid),
            "RIGHT" => Some(Function::Right),
            "SEARCH" => Some(Function::Search),
            "TEXT" => Some(Function::Text),
            "TRIM" => Some(Function::Trim),
            "UNICODE" | "_XLFN.UNICODE" => Some(Function::Unicode),
            "UPPER" => Some(Function::Upper),

            "REPT" => Some(Function::Rept),
            "TEXTAFTER" | "_XLFN.TEXTAFTER" => Some(Function::Textafter),
            "TEXTBEFORE" | "_XLFN.TEXTBEFORE" => Some(Function::Textbefore),
            "TEXTJOIN" | "_XLFN.TEXTJOIN" => Some(Function::Textjoin),
            "SUBSTITUTE" => Some(Function::Substitute),

            "ISNUMBER" => Some(Function::Isnumber),
            "ISNONTEXT" => Some(Function::Isnontext),
            "ISTEXT" => Some(Function::Istext),
            "ISLOGICAL" => Some(Function::Islogical),
            "ISBLANK" => Some(Function::Isblank),
            "ISERR" => Some(Function::Iserr),
            "ISERROR" => Some(Function::Iserror),
            "ISNA" => Some(Function::Isna),
            "NA" => Some(Function::Na),
            "ISREF" => Some(Function::Isref),
            "ISODD" => Some(Function::Isodd),
            "ISEVEN" => Some(Function::Iseven),
            "ERROR.TYPE" => Some(Function::ErrorType),
            "FORMULATEXT" | "_XLFN.FORMULATEXT" => Some(Function::Formulatext),
            "ISFORMULA" | "_XLFN.ISFORMULA" => Some(Function::Isformula),
            "TYPE" => Some(Function::Type),
            "SHEET" | "_XLFN.SHEET" => Some(Function::Sheet),

            "AVERAGE" => Some(Function::Average),
            "AVERAGEA" => Some(Function::Averagea),
            "AVERAGEIF" => Some(Function::Averageif),
            "AVERAGEIFS" => Some(Function::Averageifs),
            "COUNT" => Some(Function::Count),
            "COUNTA" => Some(Function::Counta),
            "COUNTBLANK" => Some(Function::Countblank),
            "COUNTIF" => Some(Function::Countif),
            "COUNTIFS" => Some(Function::Countifs),
            "MAXIFS" | "_XLFN.MAXIFS" => Some(Function::Maxifs),
            "MINIFS" | "_XLFN.MINIFS" => Some(Function::Minifs),
            // Date and Time
            "YEAR" => Some(Function::Year),
            "DAY" => Some(Function::Day),
            "EOMONTH" => Some(Function::Eomonth),
            "MONTH" => Some(Function::Month),
            "DATE" => Some(Function::Date),
            "EDATE" => Some(Function::Edate),
            "TODAY" => Some(Function::Today),
            "NOW" => Some(Function::Now),
            // Financial
            "PMT" => Some(Function::Pmt),
            "PV" => Some(Function::Pv),
            "RATE" => Some(Function::Rate),
            "NPER" => Some(Function::Nper),
            "FV" => Some(Function::Fv),
            "PPMT" => Some(Function::Ppmt),
            "IPMT" => Some(Function::Ipmt),
            "NPV" => Some(Function::Npv),
            "XNPV" => Some(Function::Xnpv),
            "MIRR" => Some(Function::Mirr),
            "IRR" => Some(Function::Irr),
            "XIRR" => Some(Function::Xirr),
            "ISPMT" => Some(Function::Ispmt),
            "RRI" | "_XLFN.RRI" => Some(Function::Rri),

            "SLN" => Some(Function::Sln),
            "SYD" => Some(Function::Syd),
            "NOMINAL" => Some(Function::Nominal),
            "EFFECT" => Some(Function::Effect),
            "PDURATION" | "_XLFN.PDURATION" => Some(Function::Pduration),

            "TBILLYIELD" => Some(Function::Tbillyield),
            "TBILLPRICE" => Some(Function::Tbillprice),
            "TBILLEQ" => Some(Function::Tbilleq),

            "DOLLARDE" => Some(Function::Dollarde),
            "DOLLARFR" => Some(Function::Dollarfr),

            "DDB" => Some(Function::Ddb),
            "DB" => Some(Function::Db),

            "CUMPRINC" => Some(Function::Cumprinc),
            "CUMIPMT" => Some(Function::Cumipmt),

            "BESSELI" => Some(Function::Besseli),
            "BESSELJ" => Some(Function::Besselj),
            "BESSELK" => Some(Function::Besselk),
            "BESSELY" => Some(Function::Bessely),
            "ERF" => Some(Function::Erf),
            "ERF.PRECISE" | "_XLFN.ERF.PRECISE" => Some(Function::ErfPrecise),
            "ERFC" => Some(Function::Erfc),
            "ERFC.PRECISE" | "_XLFN.ERFC.PRECISE" => Some(Function::ErfcPrecise),
            "BIN2DEC" => Some(Function::Bin2dec),
            "BIN2HEX" => Some(Function::Bin2hex),
            "BIN2OCT" => Some(Function::Bin2oct),
            "DEC2BIN" => Some(Function::Dec2Bin),
            "DEC2HEX" => Some(Function::Dec2hex),
            "DEC2OCT" => Some(Function::Dec2oct),
            "HEX2BIN" => Some(Function::Hex2bin),
            "HEX2DEC" => Some(Function::Hex2dec),
            "HEX2OCT" => Some(Function::Hex2oct),
            "OCT2BIN" => Some(Function::Oct2bin),
            "OCT2DEC" => Some(Function::Oct2dec),
            "OCT2HEX" => Some(Function::Oct2hex),
            "BITAND" | "_XLFN.BITAND" => Some(Function::Bitand),
            "BITLSHIFT" | "_XLFN.BITLSHIFT" => Some(Function::Bitlshift),
            "BITOR" | "_XLFN.BITOR" => Some(Function::Bitor),
            "BITRSHIFT" | "_XLFN.BITRSHIFT" => Some(Function::Bitrshift),
            "BITXOR" | "_XLFN.BITXOR" => Some(Function::Bitxor),
            "COMPLEX" => Some(Function::Complex),
            "IMABS" => Some(Function::Imabs),
            "IMAGINARY" => Some(Function::Imaginary),
            "IMARGUMENT" => Some(Function::Imargument),
            "IMCONJUGATE" => Some(Function::Imconjugate),
            "IMCOS" => Some(Function::Imcos),
            "IMCOSH" | "_XLFN.IMCOSH" => Some(Function::Imcosh),
            "IMCOT" | "_XLFN.IMCOT" => Some(Function::Imcot),
            "IMCSC" | "_XLFN.IMCSC" => Some(Function::Imcsc),
            "IMCSCH" | "_XLFN.IMCSCH" => Some(Function::Imcsch),
            "IMDIV" => Some(Function::Imdiv),
            "IMEXP" => Some(Function::Imexp),
            "IMLN" => Some(Function::Imln),
            "IMLOG10" => Some(Function::Imlog10),
            "IMLOG2" => Some(Function::Imlog2),
            "IMPOWER" => Some(Function::Impower),
            "IMPRODUCT" => Some(Function::Improduct),
            "IMREAL" => Some(Function::Imreal),
            "IMSEC" | "_XLFN.IMSEC" => Some(Function::Imsec),
            "IMSECH" | "_XLFN.IMSECH" => Some(Function::Imsech),
            "IMSIN" => Some(Function::Imsin),
            "IMSINH" | "_XLFN.IMSINH" => Some(Function::Imsinh),
            "IMSQRT" => Some(Function::Imsqrt),
            "IMSUB" => Some(Function::Imsub),
            "IMSUM" => Some(Function::Imsum),
            "IMTAN" | "_XLFN.IMTAN" => Some(Function::Imtan),
            "CONVERT" => Some(Function::Convert),
            "DELTA" => Some(Function::Delta),
            "GESTEP" => Some(Function::Gestep),

            "SUBTOTAL" => Some(Function::Subtotal),
            _ => None,
        }
    }
}

impl fmt::Display for Function {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Function::And => write!(f, "AND"),
            Function::False => write!(f, "FALSE"),
            Function::If => write!(f, "IF"),
            Function::Iferror => write!(f, "IFERROR"),
            Function::Ifna => write!(f, "IFNA"),
            Function::Ifs => write!(f, "IFS"),
            Function::Not => write!(f, "NOT"),
            Function::Or => write!(f, "OR"),
            Function::Switch => write!(f, "SWITCH"),
            Function::True => write!(f, "TRUE"),
            Function::Xor => write!(f, "XOR"),
            Function::Sin => write!(f, "SIN"),
            Function::Cos => write!(f, "COS"),
            Function::Tan => write!(f, "TAN"),
            Function::Asin => write!(f, "ASIN"),
            Function::Acos => write!(f, "ACOS"),
            Function::Atan => write!(f, "ATAN"),
            Function::Sinh => write!(f, "SINH"),
            Function::Cosh => write!(f, "COSH"),
            Function::Tanh => write!(f, "TANH"),
            Function::Asinh => write!(f, "ASINH"),
            Function::Acosh => write!(f, "ACOSH"),
            Function::Atanh => write!(f, "ATANH"),
            Function::Abs => write!(f, "ABS"),
            Function::Pi => write!(f, "PI"),
            Function::Sqrt => write!(f, "SQRT"),
            Function::Sqrtpi => write!(f, "SQRTPI"),
            Function::Atan2 => write!(f, "ATAN2"),
            Function::Power => write!(f, "POWER"),
            Function::Max => write!(f, "MAX"),
            Function::Min => write!(f, "MIN"),
            Function::Product => write!(f, "PRODUCT"),
            Function::Rand => write!(f, "RAND"),
            Function::Randbetween => write!(f, "RANDBETWEEN"),
            Function::Round => write!(f, "ROUND"),
            Function::Rounddown => write!(f, "ROUNDDOWN"),
            Function::Roundup => write!(f, "ROUNDUP"),
            Function::Sum => write!(f, "SUM"),
            Function::Sumif => write!(f, "SUMIF"),
            Function::Sumifs => write!(f, "SUMIFS"),
            Function::Choose => write!(f, "CHOOSE"),
            Function::Column => write!(f, "COLUMN"),
            Function::Columns => write!(f, "COLUMNS"),
            Function::Index => write!(f, "INDEX"),
            Function::Indirect => write!(f, "INDIRECT"),
            Function::Hlookup => write!(f, "HLOOKUP"),
            Function::Lookup => write!(f, "LOOKUP"),
            Function::Match => write!(f, "MATCH"),
            Function::Offset => write!(f, "OFFSET"),
            Function::Row => write!(f, "ROW"),
            Function::Rows => write!(f, "ROWS"),
            Function::Vlookup => write!(f, "VLOOKUP"),
            Function::Xlookup => write!(f, "XLOOKUP"),
            Function::Concatenate => write!(f, "CONCATENATE"),
            Function::Exact => write!(f, "EXACT"),
            Function::Value => write!(f, "VALUE"),
            Function::T => write!(f, "T"),
            Function::Valuetotext => write!(f, "VALUETOTEXT"),
            Function::Concat => write!(f, "CONCAT"),
            Function::Find => write!(f, "FIND"),
            Function::Left => write!(f, "LEFT"),
            Function::Len => write!(f, "LEN"),
            Function::Lower => write!(f, "LOWER"),
            Function::Mid => write!(f, "MID"),
            Function::Right => write!(f, "RIGHT"),
            Function::Search => write!(f, "SEARCH"),
            Function::Text => write!(f, "TEXT"),
            Function::Trim => write!(f, "TRIM"),
            Function::Unicode => write!(f, "UNICODE"),
            Function::Upper => write!(f, "UPPER"),
            Function::Isnumber => write!(f, "ISNUMBER"),
            Function::Isnontext => write!(f, "ISNONTEXT"),
            Function::Istext => write!(f, "ISTEXT"),
            Function::Islogical => write!(f, "ISLOGICAL"),
            Function::Isblank => write!(f, "ISBLANK"),
            Function::Iserr => write!(f, "ISERR"),
            Function::Iserror => write!(f, "ISERROR"),
            Function::Isna => write!(f, "ISNA"),
            Function::Na => write!(f, "NA"),
            Function::Isref => write!(f, "ISREF"),
            Function::Isodd => write!(f, "ISODD"),
            Function::Iseven => write!(f, "ISEVEN"),
            Function::ErrorType => write!(f, "ERROR.TYPE"),
            Function::Formulatext => write!(f, "FORMULATEXT"),
            Function::Isformula => write!(f, "ISFORMULA"),
            Function::Type => write!(f, "TYPE"),
            Function::Sheet => write!(f, "SHEET"),

            Function::Average => write!(f, "AVERAGE"),
            Function::Averagea => write!(f, "AVERAGEA"),
            Function::Averageif => write!(f, "AVERAGEIF"),
            Function::Averageifs => write!(f, "AVERAGEIFS"),
            Function::Count => write!(f, "COUNT"),
            Function::Counta => write!(f, "COUNTA"),
            Function::Countblank => write!(f, "COUNTBLANK"),
            Function::Countif => write!(f, "COUNTIF"),
            Function::Countifs => write!(f, "COUNTIFS"),
            Function::Maxifs => write!(f, "MAXIFS"),
            Function::Minifs => write!(f, "MINIFS"),
            Function::Year => write!(f, "YEAR"),
            Function::Day => write!(f, "DAY"),
            Function::Month => write!(f, "MONTH"),
            Function::Eomonth => write!(f, "EOMONTH"),
            Function::Date => write!(f, "DATE"),
            Function::Edate => write!(f, "EDATE"),
            Function::Today => write!(f, "TODAY"),
            Function::Now => write!(f, "NOW"),
            Function::Pmt => write!(f, "PMT"),
            Function::Pv => write!(f, "PV"),
            Function::Rate => write!(f, "RATE"),
            Function::Nper => write!(f, "NPER"),
            Function::Fv => write!(f, "FV"),
            Function::Ppmt => write!(f, "PPMT"),
            Function::Ipmt => write!(f, "IPMT"),
            Function::Npv => write!(f, "NPV"),
            Function::Mirr => write!(f, "MIRR"),
            Function::Irr => write!(f, "IRR"),
            Function::Xirr => write!(f, "XIRR"),
            Function::Xnpv => write!(f, "XNPV"),
            Function::Rept => write!(f, "REPT"),
            Function::Textafter => write!(f, "TEXTAFTER"),
            Function::Textbefore => write!(f, "TEXTBEFORE"),
            Function::Textjoin => write!(f, "TEXTJOIN"),
            Function::Substitute => write!(f, "SUBSTITUTE"),
            Function::Ispmt => write!(f, "ISPMT"),
            Function::Rri => write!(f, "RRI"),
            Function::Sln => write!(f, "SLN"),
            Function::Syd => write!(f, "SYD"),
            Function::Nominal => write!(f, "NOMINAL"),
            Function::Effect => write!(f, "EFFECT"),
            Function::Pduration => write!(f, "PDURATION"),
            Function::Tbillyield => write!(f, "TBILLYIELD"),
            Function::Tbillprice => write!(f, "TBILLPRICE"),
            Function::Tbilleq => write!(f, "TBILLEQ"),
            Function::Dollarde => write!(f, "DOLLARDE"),
            Function::Dollarfr => write!(f, "DOLLARFR"),
            Function::Ddb => write!(f, "DDB"),
            Function::Db => write!(f, "DB"),
            Function::Cumprinc => write!(f, "CUMPRINC"),
            Function::Cumipmt => write!(f, "CUMIPMT"),
            Function::Besseli => write!(f, "BESSELI"),
            Function::Besselj => write!(f, "BESSELJ"),
            Function::Besselk => write!(f, "BESSELK"),
            Function::Bessely => write!(f, "BESSELY"),
            Function::Erf => write!(f, "ERF"),
            Function::ErfPrecise => write!(f, "ERF.PRECISE"),
            Function::Erfc => write!(f, "ERFC"),
            Function::ErfcPrecise => write!(f, "ERFC.PRECISE"),
            Function::Bin2dec => write!(f, "BIN2DEC"),
            Function::Bin2hex => write!(f, "BIN2HEX"),
            Function::Bin2oct => write!(f, "BIN2OCT"),
            Function::Dec2Bin => write!(f, "DEC2BIN"),
            Function::Dec2hex => write!(f, "DEC2HEX"),
            Function::Dec2oct => write!(f, "DEC2OCT"),
            Function::Hex2bin => write!(f, "HEX2BIN"),
            Function::Hex2dec => write!(f, "HEX2DEC"),
            Function::Hex2oct => write!(f, "HEX2OCT"),
            Function::Oct2bin => write!(f, "OCT2BIN"),
            Function::Oct2dec => write!(f, "OCT2DEC"),
            Function::Oct2hex => write!(f, "OCT2HEX"),
            Function::Bitand => write!(f, "BITAND"),
            Function::Bitlshift => write!(f, "BITLSHIFT"),
            Function::Bitor => write!(f, "BITOR"),
            Function::Bitrshift => write!(f, "BITRSHIFT"),
            Function::Bitxor => write!(f, "BITXOR"),
            Function::Complex => write!(f, "COMPLEX"),
            Function::Imabs => write!(f, "IMABS"),
            Function::Imaginary => write!(f, "IMAGINARY"),
            Function::Imargument => write!(f, "IMARGUMENT"),
            Function::Imconjugate => write!(f, "IMCONJUGATE"),
            Function::Imcos => write!(f, "IMCOS"),
            Function::Imcosh => write!(f, "IMCOSH"),
            Function::Imcot => write!(f, "IMCOT"),
            Function::Imcsc => write!(f, "IMCSC"),
            Function::Imcsch => write!(f, "IMCSCH"),
            Function::Imdiv => write!(f, "IMDIV"),
            Function::Imexp => write!(f, "IMEXP"),
            Function::Imln => write!(f, "IMLN"),
            Function::Imlog10 => write!(f, "IMLOG10"),
            Function::Imlog2 => write!(f, "IMLOG2"),
            Function::Impower => write!(f, "IMPOWER"),
            Function::Improduct => write!(f, "IMPRODUCT"),
            Function::Imreal => write!(f, "IMREAL"),
            Function::Imsec => write!(f, "IMSEC"),
            Function::Imsech => write!(f, "IMSECH"),
            Function::Imsin => write!(f, "IMSIN"),
            Function::Imsinh => write!(f, "IMSINH"),
            Function::Imsqrt => write!(f, "IMSQRT"),
            Function::Imsub => write!(f, "IMSUB"),
            Function::Imsum => write!(f, "IMSUM"),
            Function::Imtan => write!(f, "IMTAN"),
            Function::Convert => write!(f, "CONVERT"),
            Function::Delta => write!(f, "DELTA"),
            Function::Gestep => write!(f, "GESTEP"),

            Function::Subtotal => write!(f, "SUBTOTAL"),
        }
    }
}

/// Documentation for one function
pub struct Documentation {
    pub name: String,
}

impl Model {
    /// Produces documentation for all implemented functions
    pub fn documentation() -> Vec<Documentation> {
        let mut doc = Vec::new();
        for function in Function::into_iter() {
            doc.push(Documentation {
                name: function.to_string(),
            });
        }
        doc
    }

    pub(crate) fn evaluate_function(
        &mut self,
        kind: &Function,
        args: &[Node],
        cell: CellReferenceIndex,
    ) -> CalcResult {
        let func: Option<fn(&mut Model, &[Node], CellReferenceIndex) -> CalcResult> = match kind {
            // Logical
            Function::Switch => Some(Model::fn_switch),
            Function::Xor => Some(Model::fn_xor),
            // Math and trigonometry
            Function::Sin => Some(Model::fn_sin),
            Function::Cos => Some(Model::fn_cos),
            Function::Tan => Some(Model::fn_tan),

            Function::Asin => Some(Model::fn_asin),
            Function::Acos => Some(Model::fn_acos),
            Function::Atan => Some(Model::fn_atan),

            Function::Sinh => Some(Model::fn_sinh),
            Function::Cosh => Some(Model::fn_cosh),
            Function::Tanh => Some(Model::fn_tanh),

            Function::Asinh => Some(Model::fn_asinh),
            Function::Acosh => Some(Model::fn_acosh),
            Function::Atanh => Some(Model::fn_atanh),

            Function::Pi => Some(Model::fn_pi),
            Function::Abs => Some(Model::fn_abs),

            Function::Sqrt => Some(Model::fn_sqrt),
            Function::Sqrtpi => Some(Model::fn_sqrtpi),
            Function::Atan2 => Some(Model::fn_atan2),
            Function::Power => Some(Model::fn_power),

            Function::Max => Some(Model::fn_max),
            Function::Min => Some(Model::fn_min),
            Function::Product => Some(Model::fn_product),
            Function::Rand => Some(Model::fn_rand),
            Function::Randbetween => Some(Model::fn_randbetween),
            Function::Round => Some(Model::fn_round),
            Function::Rounddown => Some(Model::fn_rounddown),
            Function::Roundup => Some(Model::fn_roundup),
            Function::Sumif => Some(Model::fn_sumif),
            Function::Sumifs => Some(Model::fn_sumifs),

            // Lookup and Reference
            Function::Choose => Some(Model::fn_choose),
            Function::Column => Some(Model::fn_column),
            Function::Columns => Some(Model::fn_columns),
            Function::Index => Some(Model::fn_index),
            Function::Indirect => Some(Model::fn_indirect),
            Function::Hlookup => Some(Model::fn_hlookup),
            Function::Lookup => Some(Model::fn_lookup),
            Function::Match => Some(Model::fn_match),
            Function::Offset => Some(Model::fn_offset),
            Function::Row => Some(Model::fn_row),
            Function::Rows => Some(Model::fn_rows),
            Function::Vlookup => Some(Model::fn_vlookup),
            Function::Xlookup => Some(Model::fn_xlookup),
            // Text
            Function::Concatenate => Some(Model::fn_concatenate),
            Function::Exact => Some(Model::fn_exact),
            Function::Value => Some(Model::fn_value),
            Function::T => Some(Model::fn_t),
            Function::Valuetotext => Some(Model::fn_valuetotext),
            Function::Concat => Some(Model::fn_concat),
            Function::Find => Some(Model::fn_find),
            Function::Left => Some(Model::fn_left),
            Function::Len => Some(Model::fn_len),
            Function::Lower => Some(Model::fn_lower),
            Function::Mid => Some(Model::fn_mid),
            Function::Right => Some(Model::fn_right),
            Function::Search => Some(Model::fn_search),
            Function::Text => Some(Model::fn_text),
            Function::Trim => Some(Model::fn_trim),
            Function::Unicode => Some(Model::fn_unicode),
            Function::Upper => Some(Model::fn_upper),
            // Information
            Function::Isnumber => Some(Model::fn_isnumber),
            Function::Isnontext => Some(Model::fn_isnontext),
            Function::Istext => Some(Model::fn_istext),
            Function::Islogical => Some(Model::fn_islogical),
            Function::Isblank => Some(Model::fn_isblank),
            Function::Iserr => Some(Model::fn_iserr),
            Function::Iserror => Some(Model::fn_iserror),
            Function::Isna => Some(Model::fn_isna),
            Function::Isref => Some(Model::fn_isref),
            Function::Isodd => Some(Model::fn_isodd),
            Function::Iseven => Some(Model::fn_iseven),
            Function::ErrorType => Some(Model::fn_errortype),
            Function::Formulatext => Some(Model::fn_formulatext),
            Function::Isformula => Some(Model::fn_isformula),
            Function::Type => Some(Model::fn_type),
            Function::Sheet => Some(Model::fn_sheet),
            // Statistical
            Function::Average => Some(Model::fn_average),
            Function::Averagea => Some(Model::fn_averagea),
            Function::Averageif => Some(Model::fn_averageif),
            Function::Averageifs => Some(Model::fn_averageifs),
            Function::Count => Some(Model::fn_count),
            Function::Counta => Some(Model::fn_counta),
            Function::Countblank => Some(Model::fn_countblank),
            Function::Countif => Some(Model::fn_countif),
            Function::Countifs => Some(Model::fn_countifs),
            Function::Maxifs => Some(Model::fn_maxifs),
            Function::Minifs => Some(Model::fn_minifs),
            // Date and Time
            Function::Year => Some(Model::fn_year),
            Function::Day => Some(Model::fn_day),
            Function::Eomonth => Some(Model::fn_eomonth),
            Function::Month => Some(Model::fn_month),
            Function::Date => Some(Model::fn_date),
            Function::Edate => Some(Model::fn_edate),
            Function::Today => Some(Model::fn_today),
            Function::Now => Some(Model::fn_now),
            // Financial
            Function::Pmt => Some(Model::fn_pmt),
            Function::Pv => Some(Model::fn_pv),
            Function::Rate => Some(Model::fn_rate),
            Function::Nper => Some(Model::fn_nper),
            Function::Fv => Some(Model::fn_fv),
            Function::Ppmt => Some(Model::fn_ppmt),
            Function::Ipmt => Some(Model::fn_ipmt),
            Function::Npv => Some(Model::fn_npv),
            Function::Mirr => Some(Model::fn_mirr),
            Function::Irr => Some(Model::fn_irr),
            Function::Xirr => Some(Model::fn_xirr),
            Function::Xnpv => Some(Model::fn_xnpv),
            Function::Rept => Some(Model::fn_rept),
            Function::Textafter => Some(Model::fn_textafter),
            Function::Textbefore => Some(Model::fn_textbefore),
            Function::Textjoin => Some(Model::fn_textjoin),
            Function::Substitute => Some(Model::fn_substitute),
            Function::Ispmt => Some(Model::fn_ispmt),
            Function::Rri => Some(Model::fn_rri),
            Function::Sln => Some(Model::fn_sln),
            Function::Syd => Some(Model::fn_syd),
            Function::Nominal => Some(Model::fn_nominal),
            Function::Effect => Some(Model::fn_effect),
            Function::Pduration => Some(Model::fn_pduration),
            Function::Tbillyield => Some(Model::fn_tbillyield),
            Function::Tbillprice => Some(Model::fn_tbillprice),
            Function::Tbilleq => Some(Model::fn_tbilleq),
            Function::Dollarde => Some(Model::fn_dollarde),
            Function::Dollarfr => Some(Model::fn_dollarfr),
            Function::Ddb => Some(Model::fn_ddb),
            Function::Db => Some(Model::fn_db),
            Function::Cumprinc => Some(Model::fn_cumprinc),
            Function::Cumipmt => Some(Model::fn_cumipmt),
            // Engineering
            Function::Besseli => Some(Model::fn_besseli),
            Function::Besselj => Some(Model::fn_besselj),
            Function::Besselk => Some(Model::fn_besselk),
            Function::Bessely => Some(Model::fn_bessely),
            Function::Erf => Some(Model::fn_erf),
            Function::ErfPrecise => Some(Model::fn_erfprecise),
            Function::Erfc => Some(Model::fn_erfc),
            Function::ErfcPrecise => Some(Model::fn_erfcprecise),
            Function::Bin2dec => Some(Model::fn_bin2dec),
            Function::Bin2hex => Some(Model::fn_bin2hex),
            Function::Bin2oct => Some(Model::fn_bin2oct),
            Function::Dec2Bin => Some(Model::fn_dec2bin),
            Function::Dec2hex => Some(Model::fn_dec2hex),
            Function::Dec2oct => Some(Model::fn_dec2oct),
            Function::Hex2bin => Some(Model::fn_hex2bin),
            Function::Hex2dec => Some(Model::fn_hex2dec),
            Function::Hex2oct => Some(Model::fn_hex2oct),
            Function::Oct2bin => Some(Model::fn_oct2bin),
            Function::Oct2dec => Some(Model::fn_oct2dec),
            Function::Oct2hex => Some(Model::fn_oct2hex),
            Function::Bitand => Some(Model::fn_bitand),
            Function::Bitlshift => Some(Model::fn_bitlshift),
            Function::Bitor => Some(Model::fn_bitor),
            Function::Bitrshift => Some(Model::fn_bitrshift),
            Function::Bitxor => Some(Model::fn_bitxor),
            Function::Complex => Some(Model::fn_complex),
            Function::Imabs => Some(Model::fn_imabs),
            Function::Imaginary => Some(Model::fn_imaginary),
            Function::Imargument => Some(Model::fn_imargument),
            Function::Imconjugate => Some(Model::fn_imconjugate),
            Function::Imcos => Some(Model::fn_imcos),
            Function::Imcosh => Some(Model::fn_imcosh),
            Function::Imcot => Some(Model::fn_imcot),
            Function::Imcsc => Some(Model::fn_imcsc),
            Function::Imcsch => Some(Model::fn_imcsch),
            Function::Imdiv => Some(Model::fn_imdiv),
            Function::Imexp => Some(Model::fn_imexp),
            Function::Imln => Some(Model::fn_imln),
            Function::Imlog10 => Some(Model::fn_imlog10),
            Function::Imlog2 => Some(Model::fn_imlog2),
            Function::Impower => Some(Model::fn_impower),
            Function::Improduct => Some(Model::fn_improduct),
            Function::Imreal => Some(Model::fn_imreal),
            Function::Imsec => Some(Model::fn_imsec),
            Function::Imsech => Some(Model::fn_imsech),
            Function::Imsin => Some(Model::fn_imsin),
            Function::Imsinh => Some(Model::fn_imsinh),
            Function::Imsqrt => Some(Model::fn_imsqrt),
            Function::Imsub => Some(Model::fn_imsub),
            Function::Imsum => Some(Model::fn_imsum),
            Function::Imtan => Some(Model::fn_imtan),
            Function::Convert => Some(Model::fn_convert),
            Function::Delta => Some(Model::fn_delta),
            Function::Gestep => Some(Model::fn_gestep),

            Function::Subtotal => Some(Model::fn_subtotal),
            _ => None,
        };
        if let Some(func) = func {
            return func(self, args, cell);
        }

        let func: fn(&mut Model, Vec<CalcResult>, CellReferenceIndex) -> CalcResult = match kind {
            // Logical
            Function::And => Model::fn_and,
            Function::False => fn_false,
            Function::If => Model::fn_if,
            Function::Iferror => Model::fn_iferror, // FIXME: There is no tests for this fn
            Function::Ifna => Model::fn_ifna,
            Function::Ifs => Model::fn_ifs,
            Function::Not => Model::fn_not, // FIXME: There is no tests for this fn
            Function::Or => Model::fn_or,
            Function::True => fn_true,

            Function::Sum => Model::_fn_sum,
            Function::Na => fn_na,
            _ => todo!(),
        };
        let evaluated_args = args.iter().map(|arg| self.evaluate_node_in_context(arg, cell)).collect();
        return func(self, evaluated_args, cell);

        fn fn_na(_: &mut Model, _: Vec<CalcResult>, cell: CellReferenceIndex) -> CalcResult {
            CalcResult::new_error(Error::NA, cell, "".to_string())
        }

        fn fn_true(_: &mut Model, _: Vec<CalcResult>, _: CellReferenceIndex) -> CalcResult {
            CalcResult::Boolean(true)
        }

        fn fn_false(_: &mut Model, _: Vec<CalcResult>, _: CellReferenceIndex) -> CalcResult {
            CalcResult::Boolean(false)
        }
    }
}

#[cfg(test)]
mod tests {
    #![allow(clippy::unwrap_used)]
    use std::{
        fs::File,
        io::{BufRead, BufReader},
    };

    use crate::functions::Function;

    #[test]
    fn function_iterator() {
        // This checks that the number of functions in the enum is the same
        // as the number of functions in the Iterator.

        // This is tricky. In Rust we cannot loop over all the members of an enum.
        // There are alternatives like using an external crate like strum.
        // But I am not in the mood for that.

        // What we do here is read this file , extract the functions in the enum
        // and check they are the same as in the iterator
        let file = File::open("src/functions/mod.rs").unwrap();
        let reader = BufReader::new(file);
        let mut start = false;
        let mut list = Vec::new();

        for line in reader.lines() {
            let text = line.unwrap();
            let text = text.trim().trim_end_matches(',');
            if text == "pub enum Function {" {
                start = true;
                continue;
            }
            if start {
                if text == "}" {
                    break;
                }
                if text.starts_with("//") {
                    // skip comments
                    continue;
                }
                if text.is_empty() {
                    // skip empty lines
                    continue;
                }
                list.push(text.to_owned());
            }
        }
        // We make a list with their functions names, but we escape ".": ERROR.TYPE => ERRORTYPE
        let iter_list = Function::into_iter()
            .map(|f| format!("{}", f).replace('.', ""))
            .collect::<Vec<_>>();

        let len = iter_list.len();

        assert_eq!(list.len(), len);
        // We still need to check there are no duplicates. This will fail if a function in iter_list
        // is included twice and one is missing
        for function in list {
            assert!(iter_list.contains(&function.to_uppercase()));
        }
    }
}
