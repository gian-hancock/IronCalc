use core::fmt;
use std::{array::IntoIter, collections::HashMap};

use crate::{
    calc_result::CalcResult, expressions::{parser::Node, token::Error, types::CellReferenceIndex}, language::Language, model::{CellState, Model}, types::Workbook
};

pub(crate) mod binary_search;
mod date_and_time;
mod engineering;
mod financial;
mod financial_util;
mod information;
mod logical;
mod lookup_and_reference;
mod mathematical;
mod statistical;
mod subtotal;
mod text;
mod text_util;
pub(crate) mod util;
mod xlookup;

/// List of all implemented functions
#[derive(PartialEq, Clone, Debug)]
pub enum Function {
    // Logical
    And,
    False,
    If,
    Iferror,
    Ifna,
    Ifs,
    Not,
    Or,
    Switch,
    True,
    Xor,

    // Mathematical and trigonometry
    Abs,
    Acos,
    Acosh,
    Asin,
    Asinh,
    Atan,
    Atan2,
    Atanh,
    Choose,
    Column,
    Columns,
    Cos,
    Cosh,
    Max,
    Min,
    Pi,
    Power,
    Product,
    Rand,
    Randbetween,
    Round,
    Rounddown,
    Roundup,
    Sin,
    Sinh,
    Sqrt,
    Sqrtpi,
    Sum,
    Sumif,
    Sumifs,
    Tan,
    Tanh,

    // Information
    ErrorType,
    Isblank,
    Iserr,
    Iserror,
    Iseven,
    Isformula,
    Islogical,
    Isna,
    Isnontext,
    Isnumber,
    Isodd,
    Isref,
    Istext,
    Na,
    Sheet,
    Type,

    // Lookup and reference
    Hlookup,
    Index,
    Indirect,
    Lookup,
    Match,
    Offset,
    Row,
    Rows,
    Vlookup,
    Xlookup,

    // Text
    Concat,
    Concatenate,
    Exact,
    Find,
    Left,
    Len,
    Lower,
    Mid,
    Rept,
    Right,
    Search,
    Substitute,
    T,
    Text,
    Textafter,
    Textbefore,
    Textjoin,
    Trim,
    Upper,
    Value,
    Valuetotext,

    // Statistical
    Average,
    Averagea,
    Averageif,
    Averageifs,
    Count,
    Counta,
    Countblank,
    Countif,
    Countifs,
    Maxifs,
    Minifs,

    // Date and time
    Date,
    Day,
    Edate,
    Eomonth,
    Month,
    Now,
    Today,
    Year,

    // Financial
    Cumipmt,
    Cumprinc,
    Db,
    Ddb,
    Dollarde,
    Dollarfr,
    Effect,
    Fv,
    Ipmt,
    Irr,
    Ispmt,
    Mirr,
    Nominal,
    Nper,
    Npv,
    Pduration,
    Pmt,
    Ppmt,
    Pv,
    Rate,
    Rri,
    Sln,
    Syd,
    Tbilleq,
    Tbillprice,
    Tbillyield,
    Xirr,
    Xnpv,

    // Engineering: Bessel and transcendental functions
    Besseli,
    Besselj,
    Besselk,
    Bessely,
    Erf,
    Erfc,
    ErfcPrecise,
    ErfPrecise,

    // Engineering: Number systems
    Bin2dec,
    Bin2hex,
    Bin2oct,
    Dec2Bin,
    Dec2hex,
    Dec2oct,
    Hex2bin,
    Hex2dec,
    Hex2oct,
    Oct2bin,
    Oct2dec,
    Oct2hex,

    // Engineering: Bit functions
    Bitand,
    Bitlshift,
    Bitor,
    Bitrshift,
    Bitxor,

    // Engineering: Complex functions
    Complex,
    Imabs,
    Imaginary,
    Imargument,
    Imconjugate,
    Imcos,
    Imcosh,
    Imcot,
    Imcsc,
    Imcsch,
    Imdiv,
    Imexp,
    Imln,
    Imlog10,
    Imlog2,
    Impower,
    Improduct,
    Imreal,
    Imsec,
    Imsech,
    Imsin,
    Imsinh,
    Imsqrt,
    Imsub,
    Imsum,
    Imtan,

    // Engineering: Misc function
    Convert,
    Delta,
    Gestep,
    Subtotal,
}

impl Function {
    pub fn into_iter() -> IntoIter<Function, 192> {
        [
            Function::And,
            Function::False,
            Function::If,
            Function::Iferror,
            Function::Ifna,
            Function::Ifs,
            Function::Not,
            Function::Or,
            Function::Switch,
            Function::True,
            Function::Xor,
            Function::Sin,
            Function::Cos,
            Function::Tan,
            Function::Asin,
            Function::Acos,
            Function::Atan,
            Function::Sinh,
            Function::Cosh,
            Function::Tanh,
            Function::Asinh,
            Function::Acosh,
            Function::Atanh,
            Function::Abs,
            Function::Pi,
            Function::Sqrt,
            Function::Sqrtpi,
            Function::Atan2,
            Function::Power,
            Function::Max,
            Function::Min,
            Function::Product,
            Function::Rand,
            Function::Randbetween,
            Function::Round,
            Function::Rounddown,
            Function::Roundup,
            Function::Sum,
            Function::Sumif,
            Function::Sumifs,
            Function::Choose,
            Function::Column,
            Function::Columns,
            Function::Index,
            Function::Indirect,
            Function::Hlookup,
            Function::Lookup,
            Function::Match,
            Function::Offset,
            Function::Row,
            Function::Rows,
            Function::Vlookup,
            Function::Xlookup,
            Function::Concatenate,
            Function::Exact,
            Function::Value,
            Function::T,
            Function::Valuetotext,
            Function::Concat,
            Function::Find,
            Function::Left,
            Function::Len,
            Function::Lower,
            Function::Mid,
            Function::Right,
            Function::Search,
            Function::Text,
            Function::Trim,
            Function::Upper,
            Function::Isnumber,
            Function::Isnontext,
            Function::Istext,
            Function::Islogical,
            Function::Isblank,
            Function::Iserr,
            Function::Iserror,
            Function::Isna,
            Function::Na,
            Function::Isref,
            Function::Isodd,
            Function::Iseven,
            Function::ErrorType,
            Function::Isformula,
            Function::Type,
            Function::Sheet,
            Function::Average,
            Function::Averagea,
            Function::Averageif,
            Function::Averageifs,
            Function::Count,
            Function::Counta,
            Function::Countblank,
            Function::Countif,
            Function::Countifs,
            Function::Maxifs,
            Function::Minifs,
            Function::Year,
            Function::Day,
            Function::Month,
            Function::Eomonth,
            Function::Date,
            Function::Edate,
            Function::Today,
            Function::Now,
            Function::Pmt,
            Function::Pv,
            Function::Rate,
            Function::Nper,
            Function::Fv,
            Function::Ppmt,
            Function::Ipmt,
            Function::Npv,
            Function::Mirr,
            Function::Irr,
            Function::Xirr,
            Function::Xnpv,
            Function::Rept,
            Function::Textafter,
            Function::Textbefore,
            Function::Textjoin,
            Function::Substitute,
            Function::Ispmt,
            Function::Rri,
            Function::Sln,
            Function::Syd,
            Function::Nominal,
            Function::Effect,
            Function::Pduration,
            Function::Tbillyield,
            Function::Tbillprice,
            Function::Tbilleq,
            Function::Dollarde,
            Function::Dollarfr,
            Function::Ddb,
            Function::Db,
            Function::Cumprinc,
            Function::Cumipmt,
            Function::Besseli,
            Function::Besselj,
            Function::Besselk,
            Function::Bessely,
            Function::Erf,
            Function::ErfPrecise,
            Function::Erfc,
            Function::ErfcPrecise,
            Function::Bin2dec,
            Function::Bin2hex,
            Function::Bin2oct,
            Function::Dec2Bin,
            Function::Dec2hex,
            Function::Dec2oct,
            Function::Hex2bin,
            Function::Hex2dec,
            Function::Hex2oct,
            Function::Oct2bin,
            Function::Oct2dec,
            Function::Oct2hex,
            Function::Bitand,
            Function::Bitlshift,
            Function::Bitor,
            Function::Bitrshift,
            Function::Bitxor,
            Function::Complex,
            Function::Imabs,
            Function::Imaginary,
            Function::Imargument,
            Function::Imconjugate,
            Function::Imcos,
            Function::Imcosh,
            Function::Imcot,
            Function::Imcsc,
            Function::Imcsch,
            Function::Imdiv,
            Function::Imexp,
            Function::Imln,
            Function::Imlog10,
            Function::Imlog2,
            Function::Impower,
            Function::Improduct,
            Function::Imreal,
            Function::Imsec,
            Function::Imsech,
            Function::Imsin,
            Function::Imsinh,
            Function::Imsqrt,
            Function::Imsub,
            Function::Imsum,
            Function::Imtan,
            Function::Convert,
            Function::Delta,
            Function::Gestep,
            Function::Subtotal,
        ]
        .into_iter()
    }
}

impl Function {
    /// Some functions in Excel like CONCAT are stringified as `_xlfn.CONCAT`.
    pub fn to_xlsx_string(&self) -> String {
        match self {
            Function::Concat => "_xlfn.CONCAT".to_string(),
            Function::Ifna => "_xlfn.IFNA".to_string(),
            Function::Ifs => "_xlfn.IFS".to_string(),
            Function::Maxifs => "_xlfn.MAXIFS".to_string(),
            Function::Minifs => "_xlfn.MINIFS".to_string(),
            Function::Switch => "_xlfn.SWITCH".to_string(),
            Function::Xlookup => "_xlfn.XLOOKUP".to_string(),
            Function::Xor => "_xlfn.XOR".to_string(),
            Function::Textbefore => "_xlfn.TEXTBEFORE".to_string(),
            Function::Textafter => "_xlfn.TEXTAFTER".to_string(),
            Function::Textjoin => "_xlfn.TEXTJOIN".to_string(),
            Function::Rri => "_xlfn.RRI".to_string(),
            Function::Pduration => "_xlfn.PDURATION".to_string(),
            Function::Bitand => "_xlfn.BITAND".to_string(),
            Function::Bitor => "_xlfn.BITOR".to_string(),
            Function::Bitxor => "_xlfn.BITXOR".to_string(),
            Function::Bitlshift => "_xlfn.BITLSHIFT".to_string(),
            Function::Bitrshift => "_xlfn.BITRSHIFT".to_string(),
            Function::Imtan => "_xlfn.IMTAN".to_string(),
            Function::Imsinh => "_xlfn.IMSINH".to_string(),
            Function::Imcosh => "_xlfn.IMCOSH".to_string(),
            Function::Imcot => "_xlfn.IMCOT".to_string(),
            Function::Imcsc => "_xlfn.IMCSC".to_string(),
            Function::Imcsch => "_xlfn.IMCSCH".to_string(),
            Function::Imsec => "_xlfn.IMSEC".to_string(),
            Function::ErfcPrecise => "_xlfn.ERFC.PRECISE".to_string(),
            Function::ErfPrecise => "_xlfn.ERF.PRECISE".to_string(),
            Function::Valuetotext => "_xlfn.VALUETOTEXT".to_string(),
            Function::Isformula => "_xlfn.ISFORMULA".to_string(),
            Function::Sheet => "_xlfn.SHEET".to_string(),
            _ => self.to_string(),
        }
    }

    pub(crate) fn returns_reference(&self) -> bool {
        matches!(self, Function::Indirect | Function::Offset)
    }
    /// Gets the function from the name.
    /// Note that in Excel some (modern) functions are prefixed by `_xlfn.`
    pub fn get_function(name: &str) -> Option<Function> {
        match name.to_ascii_uppercase().as_str() {
            "AND" => Some(Function::And),
            "FALSE" => Some(Function::False),
            "IF" => Some(Function::If),
            "IFERROR" => Some(Function::Iferror),
            "IFNA" | "_XLFN.IFNA" => Some(Function::Ifna),
            "IFS" | "_XLFN.IFS" => Some(Function::Ifs),
            "NOT" => Some(Function::Not),
            "OR" => Some(Function::Or),
            "SWITCH" | "_XLFN.SWITCH" => Some(Function::Switch),
            "TRUE" => Some(Function::True),
            "XOR" | "_XLFN.XOR" => Some(Function::Xor),

            "SIN" => Some(Function::Sin),
            "COS" => Some(Function::Cos),
            "TAN" => Some(Function::Tan),

            "ASIN" => Some(Function::Asin),
            "ACOS" => Some(Function::Acos),
            "ATAN" => Some(Function::Atan),

            "SINH" => Some(Function::Sinh),
            "COSH" => Some(Function::Cosh),
            "TANH" => Some(Function::Tanh),

            "ASINH" => Some(Function::Asinh),
            "ACOSH" => Some(Function::Acosh),
            "ATANH" => Some(Function::Atanh),

            "PI" => Some(Function::Pi),
            "ABS" => Some(Function::Abs),
            "SQRT" => Some(Function::Sqrt),
            "SQRTPI" => Some(Function::Sqrtpi),
            "POWER" => Some(Function::Power),
            "ATAN2" => Some(Function::Atan2),

            "MAX" => Some(Function::Max),
            "MIN" => Some(Function::Min),
            "PRODUCT" => Some(Function::Product),
            "RAND" => Some(Function::Rand),
            "RANDBETWEEN" => Some(Function::Randbetween),
            "ROUND" => Some(Function::Round),
            "ROUNDDOWN" => Some(Function::Rounddown),
            "ROUNDUP" => Some(Function::Roundup),
            "SUM" => Some(Function::Sum),
            "SUMIF" => Some(Function::Sumif),
            "SUMIFS" => Some(Function::Sumifs),

            // Lookup and Reference
            "CHOOSE" => Some(Function::Choose),
            "COLUMN" => Some(Function::Column),
            "COLUMNS" => Some(Function::Columns),
            "INDEX" => Some(Function::Index),
            "INDIRECT" => Some(Function::Indirect),
            "HLOOKUP" => Some(Function::Hlookup),
            "LOOKUP" => Some(Function::Lookup),
            "MATCH" => Some(Function::Match),
            "OFFSET" => Some(Function::Offset),
            "ROW" => Some(Function::Row),
            "ROWS" => Some(Function::Rows),
            "VLOOKUP" => Some(Function::Vlookup),
            "XLOOKUP" | "_XLFN.XLOOKUP" => Some(Function::Xlookup),

            "CONCATENATE" => Some(Function::Concatenate),
            "EXACT" => Some(Function::Exact),
            "VALUE" => Some(Function::Value),
            "T" => Some(Function::T),
            "VALUETOTEXT" | "_XLFN.VALUETOTEXT" => Some(Function::Valuetotext),
            "CONCAT" | "_XLFN.CONCAT" => Some(Function::Concat),
            "FIND" => Some(Function::Find),
            "LEFT" => Some(Function::Left),
            "LEN" => Some(Function::Len),
            "LOWER" => Some(Function::Lower),
            "MID" => Some(Function::Mid),
            "RIGHT" => Some(Function::Right),
            "SEARCH" => Some(Function::Search),
            "TEXT" => Some(Function::Text),
            "TRIM" => Some(Function::Trim),
            "UPPER" => Some(Function::Upper),

            "REPT" => Some(Function::Rept),
            "TEXTAFTER" | "_XLFN.TEXTAFTER" => Some(Function::Textafter),
            "TEXTBEFORE" | "_XLFN.TEXTBEFORE" => Some(Function::Textbefore),
            "TEXTJOIN" | "_XLFN.TEXTJOIN" => Some(Function::Textjoin),
            "SUBSTITUTE" => Some(Function::Substitute),

            "ISNUMBER" => Some(Function::Isnumber),
            "ISNONTEXT" => Some(Function::Isnontext),
            "ISTEXT" => Some(Function::Istext),
            "ISLOGICAL" => Some(Function::Islogical),
            "ISBLANK" => Some(Function::Isblank),
            "ISERR" => Some(Function::Iserr),
            "ISERROR" => Some(Function::Iserror),
            "ISNA" => Some(Function::Isna),
            "NA" => Some(Function::Na),
            "ISREF" => Some(Function::Isref),
            "ISODD" => Some(Function::Isodd),
            "ISEVEN" => Some(Function::Iseven),
            "ERROR.TYPE" => Some(Function::ErrorType),
            "ISFORMULA" | "_XLFN.ISFORMULA" => Some(Function::Isformula),
            "TYPE" => Some(Function::Type),
            "SHEET" | "_XLFN.SHEET" => Some(Function::Sheet),

            "AVERAGE" => Some(Function::Average),
            "AVERAGEA" => Some(Function::Averagea),
            "AVERAGEIF" => Some(Function::Averageif),
            "AVERAGEIFS" => Some(Function::Averageifs),
            "COUNT" => Some(Function::Count),
            "COUNTA" => Some(Function::Counta),
            "COUNTBLANK" => Some(Function::Countblank),
            "COUNTIF" => Some(Function::Countif),
            "COUNTIFS" => Some(Function::Countifs),
            "MAXIFS" | "_XLFN.MAXIFS" => Some(Function::Maxifs),
            "MINIFS" | "_XLFN.MINIFS" => Some(Function::Minifs),
            // Date and Time
            "YEAR" => Some(Function::Year),
            "DAY" => Some(Function::Day),
            "EOMONTH" => Some(Function::Eomonth),
            "MONTH" => Some(Function::Month),
            "DATE" => Some(Function::Date),
            "EDATE" => Some(Function::Edate),
            "TODAY" => Some(Function::Today),
            "NOW" => Some(Function::Now),
            // Financial
            "PMT" => Some(Function::Pmt),
            "PV" => Some(Function::Pv),
            "RATE" => Some(Function::Rate),
            "NPER" => Some(Function::Nper),
            "FV" => Some(Function::Fv),
            "PPMT" => Some(Function::Ppmt),
            "IPMT" => Some(Function::Ipmt),
            "NPV" => Some(Function::Npv),
            "XNPV" => Some(Function::Xnpv),
            "MIRR" => Some(Function::Mirr),
            "IRR" => Some(Function::Irr),
            "XIRR" => Some(Function::Xirr),
            "ISPMT" => Some(Function::Ispmt),
            "RRI" | "_XLFN.RRI" => Some(Function::Rri),

            "SLN" => Some(Function::Sln),
            "SYD" => Some(Function::Syd),
            "NOMINAL" => Some(Function::Nominal),
            "EFFECT" => Some(Function::Effect),
            "PDURATION" | "_XLFN.PDURATION" => Some(Function::Pduration),

            "TBILLYIELD" => Some(Function::Tbillyield),
            "TBILLPRICE" => Some(Function::Tbillprice),
            "TBILLEQ" => Some(Function::Tbilleq),

            "DOLLARDE" => Some(Function::Dollarde),
            "DOLLARFR" => Some(Function::Dollarfr),

            "DDB" => Some(Function::Ddb),
            "DB" => Some(Function::Db),

            "CUMPRINC" => Some(Function::Cumprinc),
            "CUMIPMT" => Some(Function::Cumipmt),

            "BESSELI" => Some(Function::Besseli),
            "BESSELJ" => Some(Function::Besselj),
            "BESSELK" => Some(Function::Besselk),
            "BESSELY" => Some(Function::Bessely),
            "ERF" => Some(Function::Erf),
            "ERF.PRECISE" | "_XLFN.ERF.PRECISE" => Some(Function::ErfPrecise),
            "ERFC" => Some(Function::Erfc),
            "ERFC.PRECISE" | "_XLFN.ERFC.PRECISE" => Some(Function::ErfcPrecise),
            "BIN2DEC" => Some(Function::Bin2dec),
            "BIN2HEX" => Some(Function::Bin2hex),
            "BIN2OCT" => Some(Function::Bin2oct),
            "DEC2BIN" => Some(Function::Dec2Bin),
            "DEC2HEX" => Some(Function::Dec2hex),
            "DEC2OCT" => Some(Function::Dec2oct),
            "HEX2BIN" => Some(Function::Hex2bin),
            "HEX2DEC" => Some(Function::Hex2dec),
            "HEX2OCT" => Some(Function::Hex2oct),
            "OCT2BIN" => Some(Function::Oct2bin),
            "OCT2DEC" => Some(Function::Oct2dec),
            "OCT2HEX" => Some(Function::Oct2hex),
            "BITAND" | "_XLFN.BITAND" => Some(Function::Bitand),
            "BITLSHIFT" | "_XLFN.BITLSHIFT" => Some(Function::Bitlshift),
            "BITOR" | "_XLFN.BITOR" => Some(Function::Bitor),
            "BITRSHIFT" | "_XLFN.BITRSHIFT" => Some(Function::Bitrshift),
            "BITXOR" | "_XLFN.BITXOR" => Some(Function::Bitxor),
            "COMPLEX" => Some(Function::Complex),
            "IMABS" => Some(Function::Imabs),
            "IMAGINARY" => Some(Function::Imaginary),
            "IMARGUMENT" => Some(Function::Imargument),
            "IMCONJUGATE" => Some(Function::Imconjugate),
            "IMCOS" => Some(Function::Imcos),
            "IMCOSH" | "_XLFN.IMCOSH" => Some(Function::Imcosh),
            "IMCOT" | "_XLFN.IMCOT" => Some(Function::Imcot),
            "IMCSC" | "_XLFN.IMCSC" => Some(Function::Imcsc),
            "IMCSCH" | "_XLFN.IMCSCH" => Some(Function::Imcsch),
            "IMDIV" => Some(Function::Imdiv),
            "IMEXP" => Some(Function::Imexp),
            "IMLN" => Some(Function::Imln),
            "IMLOG10" => Some(Function::Imlog10),
            "IMLOG2" => Some(Function::Imlog2),
            "IMPOWER" => Some(Function::Impower),
            "IMPRODUCT" => Some(Function::Improduct),
            "IMREAL" => Some(Function::Imreal),
            "IMSEC" | "_XLFN.IMSEC" => Some(Function::Imsec),
            "IMSECH" | "_XLFN.IMSECH" => Some(Function::Imsech),
            "IMSIN" => Some(Function::Imsin),
            "IMSINH" | "_XLFN.IMSINH" => Some(Function::Imsinh),
            "IMSQRT" => Some(Function::Imsqrt),
            "IMSUB" => Some(Function::Imsub),
            "IMSUM" => Some(Function::Imsum),
            "IMTAN" | "_XLFN.IMTAN" => Some(Function::Imtan),
            "CONVERT" => Some(Function::Convert),
            "DELTA" => Some(Function::Delta),
            "GESTEP" => Some(Function::Gestep),

            "SUBTOTAL" => Some(Function::Subtotal),
            _ => None,
        }
    }
}

impl fmt::Display for Function {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Function::And => write!(f, "AND"),
            Function::False => write!(f, "FALSE"),
            Function::If => write!(f, "IF"),
            Function::Iferror => write!(f, "IFERROR"),
            Function::Ifna => write!(f, "IFNA"),
            Function::Ifs => write!(f, "IFS"),
            Function::Not => write!(f, "NOT"),
            Function::Or => write!(f, "OR"),
            Function::Switch => write!(f, "SWITCH"),
            Function::True => write!(f, "TRUE"),
            Function::Xor => write!(f, "XOR"),
            Function::Sin => write!(f, "SIN"),
            Function::Cos => write!(f, "COS"),
            Function::Tan => write!(f, "TAN"),
            Function::Asin => write!(f, "ASIN"),
            Function::Acos => write!(f, "ACOS"),
            Function::Atan => write!(f, "ATAN"),
            Function::Sinh => write!(f, "SINH"),
            Function::Cosh => write!(f, "COSH"),
            Function::Tanh => write!(f, "TANH"),
            Function::Asinh => write!(f, "ASINH"),
            Function::Acosh => write!(f, "ACOSH"),
            Function::Atanh => write!(f, "ATANH"),
            Function::Abs => write!(f, "ABS"),
            Function::Pi => write!(f, "PI"),
            Function::Sqrt => write!(f, "SQRT"),
            Function::Sqrtpi => write!(f, "SQRTPI"),
            Function::Atan2 => write!(f, "ATAN2"),
            Function::Power => write!(f, "POWER"),
            Function::Max => write!(f, "MAX"),
            Function::Min => write!(f, "MIN"),
            Function::Product => write!(f, "PRODUCT"),
            Function::Rand => write!(f, "RAND"),
            Function::Randbetween => write!(f, "RANDBETWEEN"),
            Function::Round => write!(f, "ROUND"),
            Function::Rounddown => write!(f, "ROUNDDOWN"),
            Function::Roundup => write!(f, "ROUNDUP"),
            Function::Sum => write!(f, "SUM"),
            Function::Sumif => write!(f, "SUMIF"),
            Function::Sumifs => write!(f, "SUMIFS"),
            Function::Choose => write!(f, "CHOOSE"),
            Function::Column => write!(f, "COLUMN"),
            Function::Columns => write!(f, "COLUMNS"),
            Function::Index => write!(f, "INDEX"),
            Function::Indirect => write!(f, "INDIRECT"),
            Function::Hlookup => write!(f, "HLOOKUP"),
            Function::Lookup => write!(f, "LOOKUP"),
            Function::Match => write!(f, "MATCH"),
            Function::Offset => write!(f, "OFFSET"),
            Function::Row => write!(f, "ROW"),
            Function::Rows => write!(f, "ROWS"),
            Function::Vlookup => write!(f, "VLOOKUP"),
            Function::Xlookup => write!(f, "XLOOKUP"),
            Function::Concatenate => write!(f, "CONCATENATE"),
            Function::Exact => write!(f, "EXACT"),
            Function::Value => write!(f, "VALUE"),
            Function::T => write!(f, "T"),
            Function::Valuetotext => write!(f, "VALUETOTEXT"),
            Function::Concat => write!(f, "CONCAT"),
            Function::Find => write!(f, "FIND"),
            Function::Left => write!(f, "LEFT"),
            Function::Len => write!(f, "LEN"),
            Function::Lower => write!(f, "LOWER"),
            Function::Mid => write!(f, "MID"),
            Function::Right => write!(f, "RIGHT"),
            Function::Search => write!(f, "SEARCH"),
            Function::Text => write!(f, "TEXT"),
            Function::Trim => write!(f, "TRIM"),
            Function::Upper => write!(f, "UPPER"),
            Function::Isnumber => write!(f, "ISNUMBER"),
            Function::Isnontext => write!(f, "ISNONTEXT"),
            Function::Istext => write!(f, "ISTEXT"),
            Function::Islogical => write!(f, "ISLOGICAL"),
            Function::Isblank => write!(f, "ISBLANK"),
            Function::Iserr => write!(f, "ISERR"),
            Function::Iserror => write!(f, "ISERROR"),
            Function::Isna => write!(f, "ISNA"),
            Function::Na => write!(f, "NA"),
            Function::Isref => write!(f, "ISREF"),
            Function::Isodd => write!(f, "ISODD"),
            Function::Iseven => write!(f, "ISEVEN"),
            Function::ErrorType => write!(f, "ERROR.TYPE"),
            Function::Isformula => write!(f, "ISFORMULA"),
            Function::Type => write!(f, "TYPE"),
            Function::Sheet => write!(f, "SHEET"),

            Function::Average => write!(f, "AVERAGE"),
            Function::Averagea => write!(f, "AVERAGEA"),
            Function::Averageif => write!(f, "AVERAGEIF"),
            Function::Averageifs => write!(f, "AVERAGEIFS"),
            Function::Count => write!(f, "COUNT"),
            Function::Counta => write!(f, "COUNTA"),
            Function::Countblank => write!(f, "COUNTBLANK"),
            Function::Countif => write!(f, "COUNTIF"),
            Function::Countifs => write!(f, "COUNTIFS"),
            Function::Maxifs => write!(f, "MAXIFS"),
            Function::Minifs => write!(f, "MINIFS"),
            Function::Year => write!(f, "YEAR"),
            Function::Day => write!(f, "DAY"),
            Function::Month => write!(f, "MONTH"),
            Function::Eomonth => write!(f, "EOMONTH"),
            Function::Date => write!(f, "DATE"),
            Function::Edate => write!(f, "EDATE"),
            Function::Today => write!(f, "TODAY"),
            Function::Now => write!(f, "NOW"),
            Function::Pmt => write!(f, "PMT"),
            Function::Pv => write!(f, "PV"),
            Function::Rate => write!(f, "RATE"),
            Function::Nper => write!(f, "NPER"),
            Function::Fv => write!(f, "FV"),
            Function::Ppmt => write!(f, "PPMT"),
            Function::Ipmt => write!(f, "IPMT"),
            Function::Npv => write!(f, "NPV"),
            Function::Mirr => write!(f, "MIRR"),
            Function::Irr => write!(f, "IRR"),
            Function::Xirr => write!(f, "XIRR"),
            Function::Xnpv => write!(f, "XNPV"),
            Function::Rept => write!(f, "REPT"),
            Function::Textafter => write!(f, "TEXTAFTER"),
            Function::Textbefore => write!(f, "TEXTBEFORE"),
            Function::Textjoin => write!(f, "TEXTJOIN"),
            Function::Substitute => write!(f, "SUBSTITUTE"),
            Function::Ispmt => write!(f, "ISPMT"),
            Function::Rri => write!(f, "RRI"),
            Function::Sln => write!(f, "SLN"),
            Function::Syd => write!(f, "SYD"),
            Function::Nominal => write!(f, "NOMINAL"),
            Function::Effect => write!(f, "EFFECT"),
            Function::Pduration => write!(f, "PDURATION"),
            Function::Tbillyield => write!(f, "TBILLYIELD"),
            Function::Tbillprice => write!(f, "TBILLPRICE"),
            Function::Tbilleq => write!(f, "TBILLEQ"),
            Function::Dollarde => write!(f, "DOLLARDE"),
            Function::Dollarfr => write!(f, "DOLLARFR"),
            Function::Ddb => write!(f, "DDB"),
            Function::Db => write!(f, "DB"),
            Function::Cumprinc => write!(f, "CUMPRINC"),
            Function::Cumipmt => write!(f, "CUMIPMT"),
            Function::Besseli => write!(f, "BESSELI"),
            Function::Besselj => write!(f, "BESSELJ"),
            Function::Besselk => write!(f, "BESSELK"),
            Function::Bessely => write!(f, "BESSELY"),
            Function::Erf => write!(f, "ERF"),
            Function::ErfPrecise => write!(f, "ERF.PRECISE"),
            Function::Erfc => write!(f, "ERFC"),
            Function::ErfcPrecise => write!(f, "ERFC.PRECISE"),
            Function::Bin2dec => write!(f, "BIN2DEC"),
            Function::Bin2hex => write!(f, "BIN2HEX"),
            Function::Bin2oct => write!(f, "BIN2OCT"),
            Function::Dec2Bin => write!(f, "DEC2BIN"),
            Function::Dec2hex => write!(f, "DEC2HEX"),
            Function::Dec2oct => write!(f, "DEC2OCT"),
            Function::Hex2bin => write!(f, "HEX2BIN"),
            Function::Hex2dec => write!(f, "HEX2DEC"),
            Function::Hex2oct => write!(f, "HEX2OCT"),
            Function::Oct2bin => write!(f, "OCT2BIN"),
            Function::Oct2dec => write!(f, "OCT2DEC"),
            Function::Oct2hex => write!(f, "OCT2HEX"),
            Function::Bitand => write!(f, "BITAND"),
            Function::Bitlshift => write!(f, "BITLSHIFT"),
            Function::Bitor => write!(f, "BITOR"),
            Function::Bitrshift => write!(f, "BITRSHIFT"),
            Function::Bitxor => write!(f, "BITXOR"),
            Function::Complex => write!(f, "COMPLEX"),
            Function::Imabs => write!(f, "IMABS"),
            Function::Imaginary => write!(f, "IMAGINARY"),
            Function::Imargument => write!(f, "IMARGUMENT"),
            Function::Imconjugate => write!(f, "IMCONJUGATE"),
            Function::Imcos => write!(f, "IMCOS"),
            Function::Imcosh => write!(f, "IMCOSH"),
            Function::Imcot => write!(f, "IMCOT"),
            Function::Imcsc => write!(f, "IMCSC"),
            Function::Imcsch => write!(f, "IMCSCH"),
            Function::Imdiv => write!(f, "IMDIV"),
            Function::Imexp => write!(f, "IMEXP"),
            Function::Imln => write!(f, "IMLN"),
            Function::Imlog10 => write!(f, "IMLOG10"),
            Function::Imlog2 => write!(f, "IMLOG2"),
            Function::Impower => write!(f, "IMPOWER"),
            Function::Improduct => write!(f, "IMPRODUCT"),
            Function::Imreal => write!(f, "IMREAL"),
            Function::Imsec => write!(f, "IMSEC"),
            Function::Imsech => write!(f, "IMSECH"),
            Function::Imsin => write!(f, "IMSIN"),
            Function::Imsinh => write!(f, "IMSINH"),
            Function::Imsqrt => write!(f, "IMSQRT"),
            Function::Imsub => write!(f, "IMSUB"),
            Function::Imsum => write!(f, "IMSUM"),
            Function::Imtan => write!(f, "IMTAN"),
            Function::Convert => write!(f, "CONVERT"),
            Function::Delta => write!(f, "DELTA"),
            Function::Gestep => write!(f, "GESTEP"),

            Function::Subtotal => write!(f, "SUBTOTAL"),
        }
    }
}

/// Documentation for one function
pub struct Documentation {
    pub name: String,
}

impl Model {
    /// Produces documentation for all implemented functions
    pub fn documentation() -> Vec<Documentation> {
        let mut doc = Vec::new();
        for function in Function::into_iter() {
            doc.push(Documentation {
                name: function.to_string(),
            });
        }
        doc
    }

    pub(crate) fn evaluate_function(
        workbook: &Workbook,
        cells: &mut HashMap<(u32, i32, i32), CellState>,
        parsed_formulas: &Vec<Vec<Node>>,
        language: &Language,
        kind: &Function,
        args: &[Node],
        cell: CellReferenceIndex,
    ) -> CalcResult {
        match kind {
            // Logical
            Function::And => Model::fn_and(workbook, cells, parsed_formulas, language, args, cell),
            Function::False => CalcResult::Boolean(false),
            Function::If => Model::fn_if(workbook, cells, parsed_formulas, language, args, cell),
            Function::Iferror => Model::fn_iferror(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ifna => Model::fn_ifna(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ifs => Model::fn_ifs(workbook, cells, parsed_formulas, language, args, cell),
            Function::Not => Model::fn_not(workbook, cells, parsed_formulas, language, args, cell),
            Function::Or => Model::fn_or(workbook, cells, parsed_formulas, language, args, cell),
            Function::Switch => Model::fn_switch(workbook, cells, parsed_formulas, language, args, cell),
            Function::True => CalcResult::Boolean(true),
            Function::Xor => Model::fn_xor(workbook, cells, parsed_formulas, language, args, cell),
            // Math and trigonometry
            Function::Sin => Model::fn_sin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Cos => Model::fn_cos(workbook, cells, parsed_formulas, language, args, cell),
            Function::Tan => Model::fn_tan(workbook, cells, parsed_formulas, language, args, cell),

            Function::Asin => Model::fn_asin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Acos => Model::fn_acos(workbook, cells, parsed_formulas, language, args, cell),
            Function::Atan => Model::fn_atan(workbook, cells, parsed_formulas, language, args, cell),

            Function::Sinh => Model::fn_sinh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Cosh => Model::fn_cosh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Tanh => Model::fn_tanh(workbook, cells, parsed_formulas, language, args, cell),

            Function::Asinh => Model::fn_asinh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Acosh => Model::fn_acosh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Atanh => Model::fn_atanh(workbook, cells, parsed_formulas, language, args, cell),

            Function::Pi => Model::fn_pi(workbook, cells),
            Function::Abs => Model::fn_abs(workbook, cells, parsed_formulas, language, args, cell),

            Function::Sqrt => Model::fn_sqrt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sqrtpi => Model::fn_sqrtpi(workbook, cells, parsed_formulas, language, args, cell),
            Function::Atan2 => Model::fn_atan2(workbook, cells, parsed_formulas, language, args, cell),
            Function::Power => Model::fn_power(workbook, cells, parsed_formulas, language, args, cell),

            Function::Max => Model::fn_max(workbook, cells, parsed_formulas, language, args, cell),
            Function::Min => Model::fn_min(workbook, cells, parsed_formulas, language, args, cell),
            Function::Product => Model::fn_product(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rand => Model::fn_rand(workbook, cells, parsed_formulas, language, args, cell),
            Function::Randbetween => Model::fn_randbetween(workbook, cells, parsed_formulas, language, args, cell),
            Function::Round => Model::fn_round(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rounddown => Model::fn_rounddown(workbook, cells, parsed_formulas, language, args, cell),
            Function::Roundup => Model::fn_roundup(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sum => Model::fn_sum(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sumif => Model::fn_sumif(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sumifs => Model::fn_sumifs(workbook, cells, parsed_formulas, language, args, cell),

            // Lookup and Reference
            Function::Choose => Model::fn_choose(workbook, cells, parsed_formulas, language, args, cell),
            Function::Column => Model::fn_column(workbook, cells, parsed_formulas, language, args, cell),
            Function::Columns => Model::fn_columns(workbook, cells, parsed_formulas, language, args, cell),
            Function::Index => Model::fn_index(workbook, cells, parsed_formulas, language, args, cell),
            Function::Indirect => Model::fn_indirect(workbook, cells, parsed_formulas, language, args, cell),
            Function::Hlookup => Model::fn_hlookup(workbook, cells, parsed_formulas, language, args, cell),
            Function::Lookup => Model::fn_lookup(workbook, cells, parsed_formulas, language, args, cell),
            Function::Match => Model::fn_match(workbook, cells, parsed_formulas, language, args, cell),
            Function::Offset => Model::fn_offset(workbook, cells, parsed_formulas, language, args, cell),
            Function::Row => Model::fn_row(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rows => Model::fn_rows(workbook, cells, parsed_formulas, language, args, cell),
            Function::Vlookup => Model::fn_vlookup(workbook, cells, parsed_formulas, language, args, cell),
            Function::Xlookup => Model::fn_xlookup(workbook, cells, parsed_formulas, language, args, cell),
            // Text
            Function::Concatenate => Model::fn_concatenate(workbook, cells, parsed_formulas, language, args, cell),
            Function::Exact => Model::fn_exact(workbook, cells, parsed_formulas, language, args, cell),
            Function::Value => Model::fn_value(workbook, cells, parsed_formulas, language, args, cell),
            Function::T => Model::fn_t(workbook, cells, parsed_formulas, language, args, cell),
            Function::Valuetotext => Model::fn_valuetotext(workbook, cells, parsed_formulas, language, args, cell),
            Function::Concat => Model::fn_concat(workbook, cells, parsed_formulas, language, args, cell),
            Function::Find => Model::fn_find(workbook, cells, parsed_formulas, language, args, cell),
            Function::Left => Model::fn_left(workbook, cells, parsed_formulas, language, args, cell),
            Function::Len => Model::fn_len(workbook, cells, parsed_formulas, language, args, cell),
            Function::Lower => Model::fn_lower(workbook, cells, parsed_formulas, language, args, cell),
            Function::Mid => Model::fn_mid(workbook, cells, parsed_formulas, language, args, cell),
            Function::Right => Model::fn_right(workbook, cells, parsed_formulas, language, args, cell),
            Function::Search => Model::fn_search(workbook, cells, parsed_formulas, language, args, cell),
            Function::Text => Model::fn_text(workbook, cells, parsed_formulas, language, args, cell),
            Function::Trim => Model::fn_trim(workbook, cells, parsed_formulas, language, args, cell),
            Function::Upper => Model::fn_upper(workbook, cells, parsed_formulas, language, args, cell),
            // Information
            Function::Isnumber => Model::fn_isnumber(workbook, cells, parsed_formulas, language, args, cell),
            Function::Isnontext => Model::fn_isnontext(workbook, cells, parsed_formulas, language, args, cell),
            Function::Istext => Model::fn_istext(workbook, cells, parsed_formulas, language, args, cell),
            Function::Islogical => Model::fn_islogical(workbook, cells, parsed_formulas, language, args, cell),
            Function::Isblank => Model::fn_isblank(workbook, cells, parsed_formulas, language, args, cell),
            Function::Iserr => Model::fn_iserr(workbook, cells, parsed_formulas, language, args, cell),
            Function::Iserror => Model::fn_iserror(workbook, cells, parsed_formulas, language, args, cell),
            Function::Isna => Model::fn_isna(workbook, cells, parsed_formulas, language, args, cell),
            Function::Na => CalcResult::new_error(Error::NA, cell, "".to_string()),
            Function::Isref => Model::fn_isref(workbook, cells, parsed_formulas, language, args, cell),
            Function::Isodd => Model::fn_isodd(workbook, cells, parsed_formulas, language, args, cell),
            Function::Iseven => Model::fn_iseven(workbook, cells, parsed_formulas, language, args, cell),
            Function::ErrorType => Model::fn_errortype(workbook, cells, parsed_formulas, language, args, cell),
            Function::Isformula => Model::fn_isformula(workbook, cells, parsed_formulas, language, args, cell),
            Function::Type => Model::fn_type(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sheet => Model::fn_sheet(workbook, cells, parsed_formulas, language, args, cell),
            // Statistical
            Function::Average => Model::fn_average(workbook, cells, parsed_formulas, language, args, cell),
            Function::Averagea => Model::fn_averagea(workbook, cells, parsed_formulas, language, args, cell),
            Function::Averageif => Model::fn_averageif(workbook, cells, parsed_formulas, language, args, cell),
            Function::Averageifs => Model::fn_averageifs(workbook, cells, parsed_formulas, language, args, cell),
            Function::Count => Model::fn_count(workbook, cells, parsed_formulas, language, args, cell),
            Function::Counta => Model::fn_counta(workbook, cells, parsed_formulas, language, args, cell),
            Function::Countblank => Model::fn_countblank(workbook, cells, parsed_formulas, language, args, cell),
            Function::Countif => Model::fn_countif(workbook, cells, parsed_formulas, language, args, cell),
            Function::Countifs => Model::fn_countifs(workbook, cells, parsed_formulas, language, args, cell),
            Function::Maxifs => Model::fn_maxifs(workbook, cells, parsed_formulas, language, args, cell),
            Function::Minifs => Model::fn_minifs(workbook, cells, parsed_formulas, language, args, cell),
            // Date and Time
            Function::Year => Model::fn_year(workbook, cells, parsed_formulas, language, args, cell),
            Function::Day => Model::fn_day(workbook, cells, parsed_formulas, language, args, cell),
            Function::Eomonth => Model::fn_eomonth(workbook, cells, parsed_formulas, language, args, cell),
            Function::Month => Model::fn_month(workbook, cells, parsed_formulas, language, args, cell),
            Function::Date => Model::fn_date(workbook, cells, parsed_formulas, language, args, cell),
            Function::Edate => Model::fn_edate(workbook, cells, parsed_formulas, language, args, cell),
            Function::Today => Model::fn_today(workbook, cells, parsed_formulas, language, args, cell),
            Function::Now => Model::fn_now(workbook, cells, parsed_formulas, language, args, cell),
            // Financial
            Function::Pmt => Model::fn_pmt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Pv => Model::fn_pv(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rate => Model::fn_rate(workbook, cells, parsed_formulas, language, args, cell),
            Function::Nper => Model::fn_nper(workbook, cells, parsed_formulas, language, args, cell),
            Function::Fv => Model::fn_fv(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ppmt => Model::fn_ppmt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ipmt => Model::fn_ipmt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Npv => Model::fn_npv(workbook, cells, parsed_formulas, language, args, cell),
            Function::Mirr => Model::fn_mirr(workbook, cells, parsed_formulas, language, args, cell),
            Function::Irr => Model::fn_irr(workbook, cells, parsed_formulas, language, args, cell),
            Function::Xirr => Model::fn_xirr(workbook, cells, parsed_formulas, language, args, cell),
            Function::Xnpv => Model::fn_xnpv(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rept => Model::fn_rept(workbook, cells, parsed_formulas, language, args, cell),
            Function::Textafter => Model::fn_textafter(workbook, cells, parsed_formulas, language, args, cell),
            Function::Textbefore => Model::fn_textbefore(workbook, cells, parsed_formulas, language, args, cell),
            Function::Textjoin => Model::fn_textjoin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Substitute => Model::fn_substitute(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ispmt => Model::fn_ispmt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Rri => Model::fn_rri(workbook, cells, parsed_formulas, language, args, cell),
            Function::Sln => Model::fn_sln(workbook, cells, parsed_formulas, language, args, cell),
            Function::Syd => Model::fn_syd(workbook, cells, parsed_formulas, language, args, cell),
            Function::Nominal => Model::fn_nominal(workbook, cells, parsed_formulas, language, args, cell),
            Function::Effect => Model::fn_effect(workbook, cells, parsed_formulas, language, args, cell),
            Function::Pduration => Model::fn_pduration(workbook, cells, parsed_formulas, language, args, cell),
            Function::Tbillyield => Model::fn_tbillyield(workbook, cells, parsed_formulas, language, args, cell),
            Function::Tbillprice => Model::fn_tbillprice(workbook, cells, parsed_formulas, language, args, cell),
            Function::Tbilleq => Model::fn_tbilleq(workbook, cells, parsed_formulas, language, args, cell),
            Function::Dollarde => Model::fn_dollarde(workbook, cells, parsed_formulas, language, args, cell),
            Function::Dollarfr => Model::fn_dollarfr(workbook, cells, parsed_formulas, language, args, cell),
            Function::Ddb => Model::fn_ddb(workbook, cells, parsed_formulas, language, args, cell),
            Function::Db => Model::fn_db(workbook, cells, parsed_formulas, language, args, cell),
            Function::Cumprinc => Model::fn_cumprinc(workbook, cells, parsed_formulas, language, args, cell),
            Function::Cumipmt => Model::fn_cumipmt(workbook, cells, parsed_formulas, language, args, cell),
            // Engineering
            Function::Besseli => Model::fn_besseli(workbook, cells, parsed_formulas, language, args, cell),
            Function::Besselj => Model::fn_besselj(workbook, cells, parsed_formulas, language, args, cell),
            Function::Besselk => Model::fn_besselk(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bessely => Model::fn_bessely(workbook, cells, parsed_formulas, language, args, cell),
            Function::Erf => Model::fn_erf(workbook, cells, parsed_formulas, language, args, cell),
            Function::ErfPrecise => Model::fn_erfprecise(workbook, cells, parsed_formulas, language, args, cell),
            Function::Erfc => Model::fn_erfc(workbook, cells, parsed_formulas, language, args, cell),
            Function::ErfcPrecise => Model::fn_erfcprecise(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bin2dec => Model::fn_bin2dec(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bin2hex => Model::fn_bin2hex(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bin2oct => Model::fn_bin2oct(workbook, cells, parsed_formulas, language, args, cell),
            Function::Dec2Bin => Model::fn_dec2bin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Dec2hex => Model::fn_dec2hex(workbook, cells, parsed_formulas, language, args, cell),
            Function::Dec2oct => Model::fn_dec2oct(workbook, cells, parsed_formulas, language, args, cell),
            Function::Hex2bin => Model::fn_hex2bin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Hex2dec => Model::fn_hex2dec(workbook, cells, parsed_formulas, language, args, cell),
            Function::Hex2oct => Model::fn_hex2oct(workbook, cells, parsed_formulas, language, args, cell),
            Function::Oct2bin => Model::fn_oct2bin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Oct2dec => Model::fn_oct2dec(workbook, cells, parsed_formulas, language, args, cell),
            Function::Oct2hex => Model::fn_oct2hex(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bitand => Model::fn_bitand(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bitlshift => Model::fn_bitlshift(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bitor => Model::fn_bitor(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bitrshift => Model::fn_bitrshift(workbook, cells, parsed_formulas, language, args, cell),
            Function::Bitxor => Model::fn_bitxor(workbook, cells, parsed_formulas, language, args, cell),
            Function::Complex => Model::fn_complex(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imabs => Model::fn_imabs(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imaginary => Model::fn_imaginary(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imargument => Model::fn_imargument(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imconjugate => Model::fn_imconjugate(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imcos => Model::fn_imcos(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imcosh => Model::fn_imcosh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imcot => Model::fn_imcot(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imcsc => Model::fn_imcsc(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imcsch => Model::fn_imcsch(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imdiv => Model::fn_imdiv(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imexp => Model::fn_imexp(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imln => Model::fn_imln(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imlog10 => Model::fn_imlog10(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imlog2 => Model::fn_imlog2(workbook, cells, parsed_formulas, language, args, cell),
            Function::Impower => Model::fn_impower(workbook, cells, parsed_formulas, language, args, cell),
            Function::Improduct => Model::fn_improduct(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imreal => Model::fn_imreal(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsec => Model::fn_imsec(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsech => Model::fn_imsech(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsin => Model::fn_imsin(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsinh => Model::fn_imsinh(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsqrt => Model::fn_imsqrt(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsub => Model::fn_imsub(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imsum => Model::fn_imsum(workbook, cells, parsed_formulas, language, args, cell),
            Function::Imtan => Model::fn_imtan(workbook, cells, parsed_formulas, language, args, cell),
            Function::Convert => Model::fn_convert(workbook, cells, parsed_formulas, language, args, cell),
            Function::Delta => Model::fn_delta(workbook, cells, parsed_formulas, language, args, cell),
            Function::Gestep => Model::fn_gestep(workbook, cells, parsed_formulas, language, args, cell),

            Function::Subtotal => Model::fn_subtotal(workbook, cells, parsed_formulas, language, args, cell),
        }
    }
}

#[cfg(test)]
mod tests {
    use std::{
        fs::File,
        io::{BufRead, BufReader},
    };

    use crate::functions::Function;

    #[test]
    fn function_iterator() {
        // This checks that the number of functions in the enum is the same
        // as the number of functions in the Iterator.

        // This is tricky. In Rust we cannot loop over all the members of an enum.
        // There are alternatives like using an external crate like strum.
        // But I am not in the mood for that.

        // What we do here is read this file , extract the functions in the enum
        // and check they are the same as in the iterator
        let file = File::open("src/functions/mod.rs").unwrap();
        let reader = BufReader::new(file);
        let mut start = false;
        let mut list = Vec::new();

        for line in reader.lines() {
            let text = line.unwrap();
            let text = text.trim().trim_end_matches(',');
            if text == "pub enum Function {" {
                start = true;
                continue;
            }
            if start {
                if text == "}" {
                    break;
                }
                if text.starts_with("//") {
                    // skip comments
                    continue;
                }
                if text.is_empty() {
                    // skip empty lines
                    continue;
                }
                list.push(text.to_owned());
            }
        }
        // We make a list with their functions names, but we escape ".": ERROR.TYPE => ERRORTYPE
        let iter_list = Function::into_iter()
            .map(|f| format!("{}", f).replace('.', ""))
            .collect::<Vec<_>>();

        let len = iter_list.len();

        assert_eq!(list.len(), len);
        // We still need to check there are no duplicates. This will fail if a function in iter_list
        // is included twice and one is missing
        for function in list {
            assert!(iter_list.contains(&function.to_uppercase()));
        }
    }
}
